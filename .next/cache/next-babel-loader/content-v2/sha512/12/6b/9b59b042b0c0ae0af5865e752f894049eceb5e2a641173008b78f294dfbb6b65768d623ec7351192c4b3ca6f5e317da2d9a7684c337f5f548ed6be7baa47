{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { SortBy } from \"@/__generated__/type-defs.graphqls\";\nimport { Op } from \"sequelize\";\nimport models from \"../db/models\";\nconst Query = {\n  media: async (_root, args, {\n    session\n  }) => {\n    if (!(session !== null && session !== void 0 && session.user.id)) {\n      return {\n        count: 0,\n        rows: []\n      };\n    }\n\n    const conditions = {\n      where: {\n        author_id: session.user.id\n      },\n      limit: 20,\n      order: [[\"id\", SortBy.Desc]]\n    };\n\n    if (args.filters) {\n      const {\n        id,\n        authorId,\n        cursor,\n        limit,\n        page\n      } = args.filters;\n\n      if (id) {\n        conditions.where = _objectSpread(_objectSpread({}, conditions.where), {}, {\n          id\n        });\n      }\n\n      if (authorId) {\n        conditions.where = _objectSpread(_objectSpread({}, conditions.where), {}, {\n          author_id: authorId\n        });\n      }\n\n      if (limit) {\n        conditions.limit = limit;\n      }\n\n      if (cursor) {\n        conditions.where.id = {\n          [Op.gt]: cursor\n        };\n      } else if (page) {\n        conditions.offset = (page - 1) * conditions.limit;\n      }\n    }\n\n    const result = await models.Media.findAndCountAll(conditions);\n\n    if (result) {\n      const rows = result.rows.map(item => item.get());\n      return {\n        count: result.count,\n        rows: rows\n      };\n    }\n\n    return {\n      count: 0,\n      rows: []\n    };\n  }\n};\nconst Mutation = {\n  deleteMedia: async (_, args, {\n    session\n  }) => {\n    if (!(session !== null && session !== void 0 && session.user)) {\n      return {\n        __typename: \"MediaError\",\n        message: \"No Auhentication\"\n      };\n    }\n\n    const author = await models.Author.findOne({\n      where: {\n        id: session.user.id\n      }\n    });\n\n    if (!author) {\n      return {\n        __typename: \"MediaError\",\n        message: \"Author not found\"\n      };\n    }\n\n    await Promise.all([...args.ids.map(id => models.Media.destroy({\n      where: {\n        id: id,\n        author_id: session.user.id\n      }\n    }))]);\n    return {\n      __typename: \"MediaDeleteResult\",\n      ok: true\n    };\n  },\n  updateMedia: async (_, args, {\n    session\n  }) => {\n    if (!(session !== null && session !== void 0 && session.user)) {\n      return {\n        __typename: \"MediaError\",\n        message: \"No Auhentication\"\n      };\n    }\n\n    const [updates] = await models.Media.update(args.data, {\n      where: {\n        id: args.data.id,\n        author_id: session.user.id\n      }\n    });\n\n    if (updates === 0) {\n      return {\n        __typename: \"MediaError\",\n        message: \"Media not found\"\n      };\n    }\n\n    return {\n      __typename: \"MediaUpdateResult\",\n      ok: true\n    };\n  }\n};\nexport default {\n  Query,\n  Mutation\n};","map":{"version":3,"sources":["/Users/abhi/www/letterpad-admin/src/graphql/resolvers/media.ts"],"names":["SortBy","Op","models","Query","media","_root","args","session","user","id","count","rows","conditions","where","author_id","limit","order","Desc","filters","authorId","cursor","page","gt","offset","result","Media","findAndCountAll","map","item","get","Mutation","deleteMedia","_","__typename","message","author","Author","findOne","Promise","all","ids","destroy","ok","updateMedia","updates","update","data"],"mappings":";;;;;;AAAA,SAGEA,MAHF,QAIO,oCAJP;AAKA,SAASC,EAAT,QAA0B,WAA1B;AAEA,OAAOC,MAAP,MAAmB,cAAnB;AAYA,MAAMC,KAAsC,GAAG;AAC7CC,EAAAA,KAAK,EAAE,OAAOC,KAAP,EAAcC,IAAd,EAAoB;AAAEC,IAAAA;AAAF,GAApB,KAAoC;AACzC,QAAI,EAACA,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEC,IAAT,CAAcC,EAAf,CAAJ,EAAuB;AACrB,aAAO;AACLC,QAAAA,KAAK,EAAE,CADF;AAELC,QAAAA,IAAI,EAAE;AAFD,OAAP;AAID;;AACD,UAAMC,UAA4B,GAAG;AACnCC,MAAAA,KAAK,EAAE;AAAEC,QAAAA,SAAS,EAAEP,OAAO,CAACC,IAAR,CAAaC;AAA1B,OAD4B;AAEnCM,MAAAA,KAAK,EAAE,EAF4B;AAGnCC,MAAAA,KAAK,EAAE,CAAC,CAAC,IAAD,EAAOhB,MAAM,CAACiB,IAAd,CAAD;AAH4B,KAArC;;AAMA,QAAIX,IAAI,CAACY,OAAT,EAAkB;AAChB,YAAM;AAAET,QAAAA,EAAF;AAAMU,QAAAA,QAAN;AAAgBC,QAAAA,MAAhB;AAAwBL,QAAAA,KAAxB;AAA+BM,QAAAA;AAA/B,UAAwCf,IAAI,CAACY,OAAnD;;AAEA,UAAIT,EAAJ,EAAQ;AACNG,QAAAA,UAAU,CAACC,KAAX,mCAAwBD,UAAU,CAACC,KAAnC;AAA0CJ,UAAAA;AAA1C;AACD;;AACD,UAAIU,QAAJ,EAAc;AACZP,QAAAA,UAAU,CAACC,KAAX,mCAAwBD,UAAU,CAACC,KAAnC;AAA0CC,UAAAA,SAAS,EAAEK;AAArD;AACD;;AACD,UAAIJ,KAAJ,EAAW;AACTH,QAAAA,UAAU,CAACG,KAAX,GAAmBA,KAAnB;AACD;;AACD,UAAIK,MAAJ,EAAY;AACVR,QAAAA,UAAU,CAACC,KAAX,CAAiBJ,EAAjB,GAAsB;AAAE,WAACR,EAAE,CAACqB,EAAJ,GAASF;AAAX,SAAtB;AACD,OAFD,MAEO,IAAIC,IAAJ,EAAU;AACfT,QAAAA,UAAU,CAACW,MAAX,GAAoB,CAACF,IAAI,GAAG,CAAR,IAAaT,UAAU,CAACG,KAA5C;AACD;AACF;;AACD,UAAMS,MAAM,GAAG,MAAMtB,MAAM,CAACuB,KAAP,CAAaC,eAAb,CAA6Bd,UAA7B,CAArB;;AAEA,QAAIY,MAAJ,EAAY;AACV,YAAMb,IAAI,GAAGa,MAAM,CAACb,IAAP,CAAYgB,GAAZ,CAAgBC,IAAI,IAAIA,IAAI,CAACC,GAAL,EAAxB,CAAb;AACA,aAAO;AACLnB,QAAAA,KAAK,EAAEc,MAAM,CAACd,KADT;AAELC,QAAAA,IAAI,EAAEA;AAFD,OAAP;AAID;;AAED,WAAO;AACLD,MAAAA,KAAK,EAAE,CADF;AAELC,MAAAA,IAAI,EAAE;AAFD,KAAP;AAID;AA9C4C,CAA/C;AAiDA,MAAMmB,QAA4C,GAAG;AACnDC,EAAAA,WAAW,EAAE,OAAOC,CAAP,EAAU1B,IAAV,EAAgB;AAAEC,IAAAA;AAAF,GAAhB,KAAgC;AAC3C,QAAI,EAACA,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEC,IAAV,CAAJ,EAAoB;AAClB,aAAO;AACLyB,QAAAA,UAAU,EAAE,YADP;AAELC,QAAAA,OAAO,EAAE;AAFJ,OAAP;AAID;;AACD,UAAMC,MAAM,GAAG,MAAMjC,MAAM,CAACkC,MAAP,CAAcC,OAAd,CAAsB;AACzCxB,MAAAA,KAAK,EAAE;AAAEJ,QAAAA,EAAE,EAAEF,OAAO,CAACC,IAAR,CAAaC;AAAnB;AADkC,KAAtB,CAArB;;AAGA,QAAI,CAAC0B,MAAL,EAAa;AACX,aAAO;AACLF,QAAAA,UAAU,EAAE,YADP;AAELC,QAAAA,OAAO,EAAE;AAFJ,OAAP;AAID;;AACD,UAAMI,OAAO,CAACC,GAAR,CAAY,CAChB,GAAGjC,IAAI,CAACkC,GAAL,CAASb,GAAT,CAAalB,EAAE,IAChBP,MAAM,CAACuB,KAAP,CAAagB,OAAb,CAAqB;AAAE5B,MAAAA,KAAK,EAAE;AAAEJ,QAAAA,EAAE,EAAEA,EAAN;AAAUK,QAAAA,SAAS,EAAEP,OAAO,CAACC,IAAR,CAAaC;AAAlC;AAAT,KAArB,CADC,CADa,CAAZ,CAAN;AAMA,WAAO;AACLwB,MAAAA,UAAU,EAAE,mBADP;AAELS,MAAAA,EAAE,EAAE;AAFC,KAAP;AAID,GA3BkD;AA6BnDC,EAAAA,WAAW,EAAE,OAAOX,CAAP,EAAU1B,IAAV,EAAgB;AAAEC,IAAAA;AAAF,GAAhB,KAAgC;AAC3C,QAAI,EAACA,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEC,IAAV,CAAJ,EAAoB;AAClB,aAAO;AACLyB,QAAAA,UAAU,EAAE,YADP;AAELC,QAAAA,OAAO,EAAE;AAFJ,OAAP;AAID;;AAED,UAAM,CAACU,OAAD,IAAY,MAAM1C,MAAM,CAACuB,KAAP,CAAaoB,MAAb,CAAoBvC,IAAI,CAACwC,IAAzB,EAA+B;AACrDjC,MAAAA,KAAK,EAAE;AAAEJ,QAAAA,EAAE,EAAEH,IAAI,CAACwC,IAAL,CAAUrC,EAAhB;AAAoBK,QAAAA,SAAS,EAAEP,OAAO,CAACC,IAAR,CAAaC;AAA5C;AAD8C,KAA/B,CAAxB;;AAIA,QAAImC,OAAO,KAAK,CAAhB,EAAmB;AACjB,aAAO;AACLX,QAAAA,UAAU,EAAE,YADP;AAELC,QAAAA,OAAO,EAAE;AAFJ,OAAP;AAID;;AACD,WAAO;AACLD,MAAAA,UAAU,EAAE,mBADP;AAELS,MAAAA,EAAE,EAAE;AAFC,KAAP;AAID;AAnDkD,CAArD;AAsDA,eAAe;AAAEvC,EAAAA,KAAF;AAAS2B,EAAAA;AAAT,CAAf","sourcesContent":["import {\n  MutationResolvers,\n  QueryResolvers,\n  SortBy,\n} from \"@/__generated__/type-defs.graphqls\";\nimport { Op, Order } from \"sequelize\";\nimport { ResolverContext } from \"../apollo\";\nimport models from \"../db/models\";\n\ninterface IMediaConditions {\n  limit: number;\n  order: Order;\n  offset?: number;\n  where: {\n    author_id?: number;\n    id?: number | object;\n  };\n}\n\nconst Query: QueryResolvers<ResolverContext> = {\n  media: async (_root, args, { session }) => {\n    if (!session?.user.id) {\n      return {\n        count: 0,\n        rows: [],\n      };\n    }\n    const conditions: IMediaConditions = {\n      where: { author_id: session.user.id },\n      limit: 20,\n      order: [[\"id\", SortBy.Desc]],\n    };\n\n    if (args.filters) {\n      const { id, authorId, cursor, limit, page } = args.filters;\n\n      if (id) {\n        conditions.where = { ...conditions.where, id };\n      }\n      if (authorId) {\n        conditions.where = { ...conditions.where, author_id: authorId };\n      }\n      if (limit) {\n        conditions.limit = limit;\n      }\n      if (cursor) {\n        conditions.where.id = { [Op.gt]: cursor };\n      } else if (page) {\n        conditions.offset = (page - 1) * conditions.limit;\n      }\n    }\n    const result = await models.Media.findAndCountAll(conditions);\n\n    if (result) {\n      const rows = result.rows.map(item => item.get());\n      return {\n        count: result.count,\n        rows: rows,\n      };\n    }\n\n    return {\n      count: 0,\n      rows: [],\n    };\n  },\n};\n\nconst Mutation: MutationResolvers<ResolverContext> = {\n  deleteMedia: async (_, args, { session }) => {\n    if (!session?.user) {\n      return {\n        __typename: \"MediaError\",\n        message: \"No Auhentication\",\n      };\n    }\n    const author = await models.Author.findOne({\n      where: { id: session.user.id },\n    });\n    if (!author) {\n      return {\n        __typename: \"MediaError\",\n        message: \"Author not found\",\n      };\n    }\n    await Promise.all([\n      ...args.ids.map(id =>\n        models.Media.destroy({ where: { id: id, author_id: session.user.id } }),\n      ),\n    ]);\n\n    return {\n      __typename: \"MediaDeleteResult\",\n      ok: true,\n    };\n  },\n\n  updateMedia: async (_, args, { session }) => {\n    if (!session?.user) {\n      return {\n        __typename: \"MediaError\",\n        message: \"No Auhentication\",\n      };\n    }\n\n    const [updates] = await models.Media.update(args.data, {\n      where: { id: args.data.id, author_id: session.user.id },\n    });\n\n    if (updates === 0) {\n      return {\n        __typename: \"MediaError\",\n        message: \"Media not found\",\n      };\n    }\n    return {\n      __typename: \"MediaUpdateResult\",\n      ok: true,\n    };\n  },\n};\n\nexport default { Query, Mutation };\n"]},"metadata":{},"sourceType":"module"}