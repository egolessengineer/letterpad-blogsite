{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { LoginDocument } from \"@/__generated__/queries/mutations.graphql\";\nimport NextAuth from \"next-auth\";\nimport Providers from \"next-auth/providers\";\nimport { initializeApollo } from \"@/graphql/apollo\";\nimport nextConfig from \"next.config\";\nconst providers = [Providers.Credentials({\n  name: \"Credentials\",\n  credentials: {\n    email: {\n      label: \"Email\"\n    },\n    password: {\n      label: \"Password\",\n      type: \"password\"\n    }\n  },\n  authorize: async (credentials, req) => {\n    var _result$data, _result$data$login, _result$data2, _result$data2$login;\n\n    const apolloClient = await initializeApollo({}, {\n      req\n    });\n    const result = await apolloClient.mutate({\n      mutation: LoginDocument,\n      variables: {\n        data: {\n          email: credentials.email,\n          password: credentials.password\n        }\n      }\n    });\n\n    if (((_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$login = _result$data.login) === null || _result$data$login === void 0 ? void 0 : _result$data$login.__typename) === \"Author\") {\n      return _objectSpread(_objectSpread({}, result.data.login), {}, {\n        accessToken: credentials.csrfToken\n      });\n    }\n\n    if (((_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : (_result$data2$login = _result$data2.login) === null || _result$data2$login === void 0 ? void 0 : _result$data2$login.__typename) === \"LoginError\") {\n      return result.data.login;\n    }\n\n    return {\n      __typename: \"LoginError\",\n      message: \"We are facing issues logging you in. Please try after sometime\"\n    };\n  }\n})];\nconst options = {\n  providers,\n  callbacks: {\n    redirect: async (url, baseUrl) => {\n      if (url.startsWith(baseUrl)) {\n        return url;\n      }\n\n      return process.env.ROOT_URL + \"/posts\";\n    },\n    jwt: async (token, user) => {\n      //  \"user\" parameter is the object received from \"authorize\"\n      //  \"token\" is being send to \"session\" callback...\n      //  ...so we set \"user\" param of \"token\" to object from \"authorize\"...\n      //  ...and return it...\n      if (user && token && user.__typename === \"Author\") {\n        token.role = user.role;\n        token.avatar = user.avatar;\n        token.permissions = user.permissions;\n        token.id = user.id;\n        token.username = user.username;\n        token.__typename = \"SessionData\";\n      }\n\n      if (user && user.__typename === \"LoginError\") {\n        return Promise.resolve(_objectSpread({}, user));\n      }\n\n      return Promise.resolve(token);\n    },\n    session: async (session, user) => {\n      if (user.__typename === \"LoginError\") {\n        session.user = user;\n        return Promise.resolve(session);\n      }\n\n      session.user = _objectSpread({}, user);\n      return Promise.resolve(session);\n    }\n  },\n  jwt: {\n    encryption: true,\n    secret: process.env.SECRET_KEY\n  },\n  pages: {\n    signIn: `${nextConfig.basePath}/login`\n  }\n};\nexport default ((req, res) => NextAuth(req, res, options));","map":{"version":3,"sources":["/Users/abhi/www/letterpad-admin/src/pages/api/auth/[...nextauth].ts"],"names":["LoginDocument","NextAuth","Providers","initializeApollo","nextConfig","providers","Credentials","name","credentials","email","label","password","type","authorize","req","apolloClient","result","mutate","mutation","variables","data","login","__typename","accessToken","csrfToken","message","options","callbacks","redirect","url","baseUrl","startsWith","process","env","ROOT_URL","jwt","token","user","role","avatar","permissions","id","username","Promise","resolve","session","encryption","secret","SECRET_KEY","pages","signIn","basePath","res"],"mappings":"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","sourcesContent":["import {\n  LoginDocument,\n  LoginMutation,\n  LoginMutationVariables,\n  LoginResponse,\n} from \"@/__generated__/queries/mutations.graphql\";\nimport NextAuth from \"next-auth\";\nimport Providers from \"next-auth/providers\";\nimport { initializeApollo } from \"@/graphql/apollo\";\nimport { NextApiRequest, NextApiResponse } from \"next\";\nimport nextConfig from \"next.config\";\n\ninterface ICredentials {\n  email: string;\n  password: string;\n  csrfToken: string;\n}\nconst providers = [\n  Providers.Credentials({\n    name: \"Credentials\",\n    credentials: {\n      email: { label: \"Email\" },\n      password: { label: \"Password\", type: \"password\" },\n    },\n    authorize: async (\n      credentials: ICredentials,\n      req,\n    ): Promise<LoginResponse> => {\n      const apolloClient = await initializeApollo({}, { req });\n      const result = await apolloClient.mutate<\n        LoginMutation,\n        LoginMutationVariables\n      >({\n        mutation: LoginDocument,\n        variables: {\n          data: {\n            email: credentials.email,\n            password: credentials.password,\n          },\n        },\n      });\n\n      if (result.data?.login?.__typename === \"Author\") {\n        return {\n          ...result.data.login,\n          accessToken: credentials.csrfToken,\n        };\n      }\n\n      if (result.data?.login?.__typename === \"LoginError\") {\n        return result.data.login;\n      }\n\n      return {\n        __typename: \"LoginError\",\n        message:\n          \"We are facing issues logging you in. Please try after sometime\",\n      };\n    },\n  }),\n];\n\nconst options = {\n  providers,\n  callbacks: {\n    redirect: async (url: string, baseUrl: string) => {\n      if (url.startsWith(baseUrl)) {\n        return url;\n      }\n      return process.env.ROOT_URL + \"/posts\";\n    },\n    jwt: async (token: any, user: Required<LoginResponse>) => {\n      //  \"user\" parameter is the object received from \"authorize\"\n      //  \"token\" is being send to \"session\" callback...\n      //  ...so we set \"user\" param of \"token\" to object from \"authorize\"...\n      //  ...and return it...\n      if (user && token && user.__typename === \"Author\") {\n        token.role = user.role;\n        token.avatar = user.avatar;\n        token.permissions = user.permissions;\n        token.id = user.id;\n        token.username = user.username;\n        token.__typename = \"SessionData\";\n      }\n      if (user && user.__typename === \"LoginError\") {\n        return Promise.resolve({ ...user });\n      }\n      return Promise.resolve(token);\n    },\n    session: async (session: any, user: LoginResponse) => {\n      if (user.__typename === \"LoginError\") {\n        session.user = user;\n        return Promise.resolve(session);\n      }\n      session.user = { ...user };\n      return Promise.resolve(session);\n    },\n  },\n  jwt: {\n    encryption: true,\n    secret: process.env.SECRET_KEY,\n  },\n  pages: {\n    signIn: `${nextConfig.basePath}/login`,\n  },\n};\n\nexport default (req: NextApiRequest, res: NextApiResponse) =>\n  NextAuth(req, res, options);\n"]},"metadata":{},"sourceType":"module"}