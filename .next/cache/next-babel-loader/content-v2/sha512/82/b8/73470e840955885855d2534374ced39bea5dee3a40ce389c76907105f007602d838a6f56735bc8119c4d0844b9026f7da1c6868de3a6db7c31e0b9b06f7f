{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport models from \"../db/models\";\nconst Query = {\n  async tag(_root, args, {\n    session,\n    author_id\n  }) {\n    const authorId = (session === null || session === void 0 ? void 0 : session.user.id) || author_id;\n\n    if (!authorId) {\n      return {\n        __typename: \"TagResultError\",\n        message: \"You dont have access to get this resource\"\n      };\n    }\n\n    const tag = await models.Tags.findOne({\n      where: {\n        slug: args.slug\n      }\n    });\n\n    if (tag) {\n      return _objectSpread({\n        __typename: \"Tags\"\n      }, tag.get());\n    }\n\n    return {\n      __typename: \"TagResultError\",\n      message: \"Tag not found\"\n    };\n  },\n\n  async tags(_root, args, {\n    session,\n    author_id\n  }) {\n    const authorId = (session === null || session === void 0 ? void 0 : session.user.id) || author_id;\n\n    if (!authorId) {\n      return {\n        __typename: \"TagsError\",\n        message: \"Missing or invalid token or session\"\n      };\n    }\n\n    let conditions = {\n      where: {},\n      order: [[\"name\", \"ASC\"]]\n    };\n\n    if (args.filters) {\n      let {\n        active,\n        name\n      } = args.filters;\n\n      if (typeof active === \"undefined\") {\n        active = true;\n      }\n\n      if (name) {\n        conditions.where.name = name;\n      }\n\n      if (active === true) {\n        // return only active taxonomies\n        conditions.include = [{\n          model: models.Post,\n          where: {\n            status: \"published\"\n          },\n          required: true\n        }];\n        conditions.group = [\"tag_id\", \"post_id\"];\n      }\n    }\n\n    const author = await models.Author.findOne({\n      where: {\n        id: authorId\n      }\n    });\n\n    if (author) {\n      const tags = await author.getTags(conditions);\n      return {\n        __typename: \"TagsNode\",\n        rows: tags.map(tag => tag.get())\n      };\n    }\n\n    return {\n      __typename: \"TagsError\",\n      message: \"Missing or invalid token or session\"\n    };\n  }\n\n};\nconst Tags = {\n  async posts({\n    id\n  }) {\n    const tag = await models.Tags.findOne({\n      where: {\n        id\n      }\n    });\n    const posts = await (tag === null || tag === void 0 ? void 0 : tag.getPosts({\n      where: {\n        status: \"published\"\n      }\n    }));\n    return {\n      __typename: \"PostsNode\",\n      count: posts === null || posts === void 0 ? void 0 : posts.length,\n      rows: posts === null || posts === void 0 ? void 0 : posts.map(post => post === null || post === void 0 ? void 0 : post.get())\n    };\n  }\n\n};\nconst Mutation = {\n  async updateTags(_root, args, {\n    session\n  }) {\n    var _args$data$slug;\n\n    if (!(session !== null && session !== void 0 && session.user)) {\n      return {\n        __typename: \"TagsError\",\n        message: \"No session found\"\n      };\n    }\n\n    const author = await models.Author.findOne({\n      where: {\n        id: session.user.id\n      }\n    });\n\n    if (!args.data || !author) {\n      return {\n        __typename: \"TagsError\",\n        message: \"Incorrect arguments\"\n      };\n    }\n\n    let tag;\n    args.data.slug = (_args$data$slug = args.data.slug) === null || _args$data$slug === void 0 ? void 0 : _args$data$slug.split(\"/\").pop();\n\n    if (args.data.id === 0) {\n      tag = await author.createTag(args.data);\n    } else {\n      tag = await models.Tags.update(args.data, {\n        where: {\n          id: args.data.id\n        }\n      });\n    }\n\n    if (!tag) {\n      return {\n        __typename: \"TagsError\",\n        message: \"Failed to update tags\"\n      };\n    }\n\n    return {\n      __typename: \"EditTaxResponse\",\n      ok: true\n    };\n  },\n\n  async deleteTags(_root, args, _context) {\n    if (!args.id) {\n      return {\n        __typename: \"TagsError\",\n        message: \"Incorrect arguments\"\n      };\n    }\n\n    const deleteRowCount = await models.Tags.destroy({\n      where: {\n        id: args.id\n      }\n    });\n\n    if (deleteRowCount === 1) {\n      return {\n        __typename: \"DeleteTagsResult\",\n        ok: true\n      };\n    }\n\n    return {\n      __typename: \"TagsError\",\n      message: \"Unable to delete tag.\"\n    };\n  }\n\n};\nexport default {\n  Query,\n  Tags,\n  Mutation\n};","map":{"version":3,"sources":["/Users/abhi/www/letterpad-admin/src/graphql/resolvers/tag.ts"],"names":["models","Query","tag","_root","args","session","author_id","authorId","user","id","__typename","message","Tags","findOne","where","slug","get","tags","conditions","order","filters","active","name","include","model","Post","status","required","group","author","Author","getTags","rows","map","posts","getPosts","count","length","post","Mutation","updateTags","data","split","pop","createTag","update","ok","deleteTags","_context","deleteRowCount","destroy"],"mappings":"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","sourcesContent":["import { GroupOption, Includeable, Order } from \"sequelize\";\nimport { MutationResolvers } from \"./../../../__generated__/src/graphql/type-defs.graphqls\";\nimport { ResolverContext } from \"../apollo\";\nimport { QueryResolvers } from \"@/__generated__/type-defs.graphqls\";\nimport models from \"../db/models\";\n\nconst Query: QueryResolvers<ResolverContext> = {\n  async tag(_root, args, { session, author_id }) {\n    const authorId = session?.user.id || author_id;\n\n    if (!authorId) {\n      return {\n        __typename: \"TagResultError\",\n        message: \"You dont have access to get this resource\",\n      };\n    }\n\n    const tag = await models.Tags.findOne({ where: { slug: args.slug } });\n\n    if (tag) {\n      return {\n        __typename: \"Tags\",\n        ...tag.get(),\n      };\n    }\n    return {\n      __typename: \"TagResultError\",\n      message: \"Tag not found\",\n    };\n  },\n  async tags(_root, args, { session, author_id }) {\n    const authorId = session?.user.id || author_id;\n\n    if (!authorId) {\n      return {\n        __typename: \"TagsError\",\n        message: \"Missing or invalid token or session\",\n      };\n    }\n    let conditions: {\n      where: {\n        name?: string;\n      };\n      group?: GroupOption;\n      include?: Includeable | Includeable[];\n      order: Order;\n    } = {\n      where: {},\n      order: [[\"name\", \"ASC\"]],\n    };\n    if (args.filters) {\n      let { active, name } = args.filters;\n      if (typeof active === \"undefined\") {\n        active = true;\n      }\n\n      if (name) {\n        conditions.where.name = name;\n      }\n      if (active === true) {\n        // return only active taxonomies\n        conditions.include = [\n          {\n            model: models.Post,\n            where: { status: \"published\" },\n            required: true,\n          },\n        ];\n        conditions.group = [\"tag_id\", \"post_id\"];\n      }\n    }\n\n    const author = await models.Author.findOne({\n      where: { id: authorId },\n    });\n    if (author) {\n      const tags = await author.getTags(conditions);\n      return {\n        __typename: \"TagsNode\",\n        rows: tags.map(tag => tag.get()),\n      };\n    }\n\n    return {\n      __typename: \"TagsError\",\n      message: \"Missing or invalid token or session\",\n    };\n  },\n};\n\nconst Tags = {\n  async posts({ id }) {\n    const tag = await models.Tags.findOne({ where: { id } });\n    const posts = await tag?.getPosts({ where: { status: \"published\" } });\n    return {\n      __typename: \"PostsNode\",\n      count: posts?.length,\n      rows: posts?.map(post => post?.get()),\n    };\n  },\n};\n\nconst Mutation: MutationResolvers<ResolverContext> = {\n  async updateTags(_root, args, { session }) {\n    if (!session?.user) {\n      return {\n        __typename: \"TagsError\",\n        message: \"No session found\",\n      };\n    }\n\n    const author = await models.Author.findOne({\n      where: { id: session.user.id },\n    });\n\n    if (!args.data || !author) {\n      return {\n        __typename: \"TagsError\",\n        message: \"Incorrect arguments\",\n      };\n    }\n\n    let tag: unknown;\n    args.data.slug = args.data.slug?.split(\"/\").pop();\n    if (args.data.id === 0) {\n      tag = await author.createTag(args.data);\n    } else {\n      tag = await models.Tags.update(args.data, {\n        where: { id: args.data.id },\n      });\n    }\n\n    if (!tag) {\n      return {\n        __typename: \"TagsError\",\n        message: \"Failed to update tags\",\n      };\n    }\n    return {\n      __typename: \"EditTaxResponse\",\n      ok: true,\n    };\n  },\n\n  async deleteTags(_root, args, _context) {\n    if (!args.id) {\n      return {\n        __typename: \"TagsError\",\n        message: \"Incorrect arguments\",\n      };\n    }\n\n    const deleteRowCount = await models.Tags.destroy({\n      where: { id: args.id },\n    });\n\n    if (deleteRowCount === 1) {\n      return {\n        __typename: \"DeleteTagsResult\",\n        ok: true,\n      };\n    }\n    return {\n      __typename: \"TagsError\",\n      message: \"Unable to delete tag.\",\n    };\n  },\n};\nexport default { Query, Tags, Mutation };\n"]},"metadata":{},"sourceType":"module"}